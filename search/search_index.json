{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tennis MCP \u2014 Autonomous Betting Platform","text":"<p>Welcome! This site explains what the platform does, how it works, and how to run it.</p> <p>Goal: Use machine learning to estimate win probabilities, compare them to market odds, and bet only when there is value \u2014 automatically and safely.</p> <p>At a glance:</p> <ul> <li>Predict win probabilities for tennis matches (model or baseline).</li> <li>Compute fair odds and edge vs market prices.</li> <li>Place bets only if edge \u2265 threshold; size stakes via capped Kelly.</li> <li>Observe decisions and performance via Prometheus + Grafana.</li> <li>Roll out gradually: backtest \u2192 simulate (shadow) \u2192 real money.</li> </ul> <p>For a story-like explanation for different audiences, see MCP &amp; Strategy.</p>"},{"location":"00-architecture-overview/","title":"Architecture Overview (with pictures)","text":"<p>Purpose: a responsive, safe, and observable tennis betting agent that reacts to live odds, compares them to model fair odds, and places value bets with strict risk limits.</p>"},{"location":"00-architecture-overview/#diagram-big-picture","title":"Diagram \u2013 Big Picture","text":"<pre><code>flowchart LR\n  BF[Betfair Exchange\nStream API] --&gt;|prices, order updates| Agent\n  subgraph Agent[Agent (Flumine + MCP)]\n    S[Strategy\n(MCPTennisStrategy)]\n    M[MCP\n(fair odds &amp; edge)]\n    R[Risk &amp; Circuit Breakers]\n    E[Executor\n(place/cancel)]\n    S --&gt; M --&gt; R --&gt; E\n  end\n  Agent --&gt;|/metrics| Prom[Prometheus]\n  Prom --&gt; Grafana[Grafana Dashboard]\n  Agent --&gt;|optional| PredAPI[Prediction API\n(prob_a, prob_b)]\n</code></pre> <ul> <li>Stream API feeds low\u2011latency market updates; we avoid expensive REST polling. \ue200cite\ue202turn0search3\ue202turn0search19\ue201  </li> <li>Flumine hosts our Strategy, consumes the stream, and handles paper/real execution. \ue200cite\ue202turn0search0\ue202turn0search16\ue201  </li> <li>MCP converts probabilities \u2192 fair odds and finds edge; stake sizing via capped Kelly.  </li> <li>Prometheus &amp; Grafana expose health and performance (P/L, ROI, exposure). \ue200cite\ue202turn0search4\ue202turn0search21\ue201</li> </ul>"},{"location":"01-runbook-local-sim-shadow/","title":"Runbook \u2013 Local 24h SIM Shadow","text":"<p>Goal: run the agent safely against live prices for 24h (paper trading only).</p>"},{"location":"01-runbook-local-sim-shadow/#steps","title":"Steps","text":"<p><pre><code>python -m agents.betfair_agent.run_agent --mode SIM --inplay-only\n</code></pre> - Flumine paper trading simulates execution; market data still comes from live stream. \ue200cite\ue202turn0search0\ue201</p>"},{"location":"01-runbook-local-sim-shadow/#verify","title":"Verify","text":"<ul> <li>Visit <code>http://localhost:9100/metrics</code> \u2013 counters rising means healthy scrape. \ue200cite\ue202turn0search4\ue201</li> </ul>"},{"location":"02-runbook-k8s-helm-argocd/","title":"Runbook \u2013 Kubernetes (Helm) &amp; GitOps (Argo CD)","text":""},{"location":"02-runbook-k8s-helm-argocd/#helm-quickstart-sim","title":"Helm quickstart (SIM)","text":"<pre><code>helm upgrade --install tennis charts/tennis -n tennis-dev --create-namespace   --set agent.mode=SIM   --set agent.serviceMonitor.enabled=true   --set agent.grafanaDashboard.enabled=true\n</code></pre>"},{"location":"02-runbook-k8s-helm-argocd/#argo-cd-valuesobject","title":"Argo CD (valuesObject)","text":"<p>Point the Application at <code>charts/tennis</code> and use inline <code>valuesObject</code> to set env\u2011specific values. \ue200cite\ue202turn1search0\ue201</p> <pre><code>spec:\n  source:\n    helm:\n      valuesObject:\n        agent:\n          mode: SIM\n          serviceMonitor: { enabled: true, release: prometheus }\n</code></pre>"},{"location":"03-runbook-openshift-uwm/","title":"Runbook \u2013 OpenShift User Workload Monitoring (UWM)","text":"<p>Goal: let OpenShift scrape the agent via <code>ServiceMonitor</code> and visualize in the web console.</p>"},{"location":"03-runbook-openshift-uwm/#enable-uwm","title":"Enable UWM","text":"<p>Edit (or create) the ConfigMap in <code>openshift-monitoring</code>: <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: cluster-monitoring-config\n  namespace: openshift-monitoring\ndata:\n  config.yaml: |\n    enableUserWorkload: true\n</code></pre> OpenShift will deploy the user\u2011workload Prometheus to scrape your namespaces. \ue200cite\ue202turn0search15\ue202turn2search1\ue201</p>"},{"location":"03-runbook-openshift-uwm/#screenshots-reference","title":"Screenshots (reference)","text":"<ul> <li> <p>Observe \u2192 Targets shows user workloads after your <code>ServiceMonitor</code> is applied (see Figure 2 in this article).    (Scroll to Figure 2 on that page.) \ue200cite\ue202turn2search2\ue201</p> </li> <li> <p>Red Hat docs step\u2011by\u2011step (with console views). https://docs.redhat.com/.../monitoring/enabling-monitoring-for-user-defined-projects  \ue200cite\ue202turn0search7\ue201</p> </li> </ul>"},{"location":"03-runbook-openshift-uwm/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure the project is not excluded (no label <code>openshift.io/user-monitoring=false</code>). \ue200cite\ue202turn2search6\ue201</li> </ul>"},{"location":"04-runbook-observability/","title":"Observability \u2013 Prometheus, ServiceMonitor, Grafana","text":"<ul> <li>The agent exports metrics with <code>prometheus_client.start_http_server(port)</code> (default 9100). \ue200cite\ue202turn0search4\ue201  </li> <li>You can serve HTTPS metrics by providing <code>certfile</code>/<code>keyfile</code>. \ue200cite\ue202turn0search12\ue201  </li> <li>Prometheus Operator scrapes via ServiceMonitor; rules via PrometheusRule CRD (both included in the chart). \ue200cite\ue202turn0search21\ue202turn0search5\ue201</li> </ul>"},{"location":"04-runbook-observability/#dashboard","title":"Dashboard","text":"<p>We ship a ConfigMap labeled so Grafana\u2019s sidecar auto\u2011loads dashboards. (Common pattern in kube\u2011prometheus\u2011stack.) \ue200cite\ue202turn1search10\ue202turn1search5\ue201</p>"},{"location":"05-runbook-alerts-and-slos/","title":"Alerts &amp; SLOs","text":"<p>We include a <code>PrometheusRule</code> template with: - AgentDailyStopLossBreached \u2013 fires when <code>daily_pnl</code> &lt;= \u2212X for 5m - AgentNoData \u2013 no MCP evals for 15m - AgentHighExposure \u2013 pending exposure &gt; threshold for 10m</p> <p>These are picked up automatically by Prometheus Operator. \ue200cite\ue202turn0search5\ue202turn0search6\ue201</p>"},{"location":"06-runbook-secrets-gitops/","title":"Secrets via GitOps","text":"<p>Use Sealed Secrets or External Secrets Operator to keep credentials out of plaintext Git: - Sealed Secrets: encrypts Secrets client\u2011side; only the cluster can decrypt. - External Secrets Operator: syncs from AWS/GCP/Vault to K8s Secrets. \ue200cite\ue202turn1search6\ue201</p>"},{"location":"07-runbook-real-cutover-and-controls/","title":"Cutover to REAL (small stakes)","text":"<ul> <li>Switch <code>agent.mode=REAL</code>, provide Betfair credentials and (optionally) client cert for non\u2011interactive login (<code>certlogin</code>). \ue200cite\ue202turn0search2\ue201</li> <li>Expect in\u2011play bet delays (1\u201312s typical); keep Kelly cap low initially. \ue200cite\ue202turn0search19\ue201</li> <li>Watch <code>pnl_total</code>, <code>roi_total</code>, <code>pending_exposure</code>, <code>daily_pnl</code>. Add Slack/email routes in Alertmanager.</li> </ul>"},{"location":"08-runbook-incident-response/","title":"Incident Response","text":"<p>Pause trading: <code>kubectl -n &lt;ns&gt; scale deploy &lt;agent&gt; --replicas=0</code> Flip to SIM: <code>agent.mode=SIM</code> in values; sync via Argo CD. Check stream health and account endpoints before resuming. \ue200cite\ue202turn0search19\ue201</p>"},{"location":"09-runbook-upgrade-rollback-gitops/","title":"Upgrade/Rollback with Argo CD","text":"<ul> <li>Update image tag or values in Git; Argo CD reconciles.  </li> <li>Rollback: revert commit or use Argo CD Rollback UI.  </li> <li><code>valuesObject</code> used for inline per\u2011env overrides. \ue200cite\ue202turn1search0\ue201</li> </ul>"},{"location":"10-runbook-threshold-tuning/","title":"Threshold Tuning","text":"<p>Use the Airflow <code>mcp_threshold_sweep</code> DAG to run parallel SIM agents (2\u20134 hours each). Compare ROI and P/L; choose a conservative threshold that holds across tournaments/days. Paper trading simulates execution. \ue200cite\ue202turn0search0\ue201</p>"},{"location":"11-runbook-pl-reconciliation/","title":"P/L Reconciliation","text":"<p>We compute P/L at market settlement from <code>runner.status==WINNER</code> as a quick check; for official reporting use Betfair listClearedOrders and/or account statement APIs. \ue200cite\ue202turn0search26\ue201</p>"},{"location":"12-betfair-integration-notes/","title":"Betfair Integration Notes","text":"<ul> <li>Stream API: low latency market &amp; order updates, designed to avoid polling. \ue200cite\ue202turn0search3\ue202turn0search19\ue201</li> <li>flumine: event\u2011based trading framework; paper_trade=True for shadow runs. \ue200cite\ue202turn0search0\ue201</li> <li>betfairlightweight: Python client wrapper with login and streaming support. \ue200cite\ue202turn0search17\ue201</li> <li>Non\u2011interactive cert login: upload cert and use <code>certlogin</code> flow. \ue200cite\ue202turn0search2\ue201</li> </ul>"},{"location":"13-prediction-api-contract/","title":"Prediction API Contract","text":"<p>POST <code>/predict</code> with <code>{ \"player_a\": \"...\", \"player_b\": \"...\", \"score\": \"optional\" }</code> Response <code>{ \"prob_a\": 0.62, \"prob_b\": 0.38 }</code> (will be normalized). If the API is down, MCP falls back to market\u2011implied probabilities.</p> <p>Metrics &amp; calls should be cached per match to reduce load.</p>"},{"location":"14-security-compliance-basics/","title":"Security &amp; Compliance Basics","text":"<ul> <li>Use GitOps\u2011friendly secrets (Sealed/External Secrets). \ue200cite\ue202turn1search6\ue201</li> <li>Never log raw session tokens or passwords.  </li> <li>Keep Betfair usage within terms and rate limits; prefer Stream API where possible. \ue200cite\ue202turn0search19\ue201</li> </ul>"},{"location":"PR_GUIDE/","title":"PR Guide \u2014 Extended","text":"<p><pre><code>git checkout -b feat/agent-mode-observability\nunzip woow-agent-pr-extended.zip -d .\ngit add agents/ charts/ grafana/ airflow/ docker/ docs/ gitops/ requirements_agent.txt .github/workflows/agent-ci.yml\ngit commit -m \"feat(agent): MCP agent + metrics + PrometheusRule + OpenShift UWM docs &amp; diagrams\"\ngit push origin feat/agent-mode-observability\n</code></pre> Open a PR and link to: - <code>docs/00-architecture-overview.md</code> - <code>docs/ai-ml-explained.md</code> - <code>docs/03-runbook-openshift-uwm.md</code> - <code>docs/04-runbook-observability.md</code></p>"},{"location":"README-APPLY/","title":"How to apply this overlay","text":"<p>1) From your repo root, unzip this file:    <pre><code>unzip woow-mega-docs-extra.zip -d .\n</code></pre> 2) Append the contents of <code>mkdocs.yml.append</code> to your existing <code>mkdocs.yml</code> nav (under <code>nav:</code>).    You can insert them after the existing entries, for example:    <pre><code>nav:\n  - Home: index.md\n  - Architecture: architecture.md\n  # ...\n# Append the lines below:\n(contents of mkdocs.yml.append)\n</code></pre> 3) Commit and push:    <pre><code>git add docs mkdocs.yml docs/README-APPLY.md\ngit commit -m \"docs: GH Pages guide, calibration demo, extra diagrams, OpenShift UWM page\"\ngit push\n</code></pre> 4) Enable GitHub Pages as described in <code>docs/github-pages.md</code>.</p>"},{"location":"README-OPENSHIFT-UWM/","title":"OpenShift \u2013 User Workload Monitoring (with screenshots)","text":"<p>1) Enable UWM by setting <code>enableUserWorkload: true</code> in <code>cluster-monitoring-config</code> (namespace <code>openshift-monitoring</code>). \ue200cite\ue202turn0search15\ue201 2) Deploy our chart (Service + ServiceMonitor). Prometheus UWM will discover and scrape <code>/metrics</code>. \ue200cite\ue202turn0search21\ue201 3) Open the web console \u2192 Observe \u2192 Targets; you should see the agent target (see figure in this article).  \ue200cite\ue202turn2search2\ue201</p> <p>Tips - Check your namespace is not excluded from UWM: no label <code>openshift.io/user-monitoring=false</code>. \ue200cite\ue202turn2search6\ue201 - You can attach PrometheusRule alerts; OpenShift shows alerts under Observe \u2192 Alerting. \ue200cite\ue202turn2search0\ue201</p>"},{"location":"ai-ml-explained/","title":"AI/ML Construction \u2014 Explained for Everyone","text":""},{"location":"ai-ml-explained/#for-a-small-child-57","title":"For a small child (5\u20137)","text":"<p>Imagine two players are racing. We try to guess who will win by looking at how fast they usually run. If the shop says Alice wins pays 2 candies for 1, and we think Alice should pay 3 candies for 1 (because she is very strong today), then the shop is giving us a good deal. We take a small candy bet. If the deal is not good, we wait.</p>"},{"location":"ai-ml-explained/#for-a-bigger-child-812","title":"For a bigger child (8\u201312)","text":"<p>We turn chances into fair prices. If we think a player has a 60% chance to win, the fair price is <code>1 / 0.6 = 1.67</code>. If the market offers 2.0, that\u2019s better than fair (extra value). We only bet when value is big enough (say +5%). We also control how much we risk with a rule called Kelly so we don\u2019t lose too much at once.</p>"},{"location":"ai-ml-explained/#for-mum-grandmom","title":"For mum &amp; grandmom","text":"<p>We run a program that watches the live odds feed. Our model estimates each player\u2019s win probability. From that, we compute a fair price and compare to the market\u2019s price in real time. When the market is sufficiently generous, we place a small, sized bet. We record all actions and results, and dashboards show profit, return, and risk so you can see it\u2019s safe and controlled.</p>"},{"location":"ai-ml-explained/#for-engineers-technical","title":"For engineers (technical)","text":"<ul> <li>Inputs: live prices from the Betfair Exchange Stream API; optional model probabilities from a REST Prediction API. \ue200cite\ue202turn0search3\ue201  </li> <li>Model \u2192 Price: <code>fair_odds = 1 / p</code>. Edge = <code>(market_back - fair) / fair</code>.  </li> <li>Decision: if <code>edge \u2265 threshold</code>, place a <code>BACK</code> limit order at best available price.  </li> <li>Stake sizing: capped Kelly fraction <code>f* = (b*p - (1-p)) / b</code>, where <code>b = odds - 1</code>; <code>stake = bankroll * min(f*, max_risk_pct)</code>.  </li> <li>Execution: strategy loop in flumine; SIM mode uses paper trading for safe shadow runs. \ue200cite\ue202turn0search0\ue201  </li> <li>Observability: Prometheus metrics (<code>/metrics</code>) scraped via ServiceMonitor; alerts via PrometheusRule; Grafana dashboard from ConfigMap. \ue200cite\ue202turn0search21\ue202turn0search5\ue201</li> </ul>"},{"location":"ai-ml-explained/#pictures-mermaid","title":"Pictures (Mermaid)","text":""},{"location":"ai-ml-explained/#agent-loop","title":"Agent loop","text":"<pre><code>sequenceDiagram\n  participant Stream as Exchange Stream\n  participant Strat as Strategy\n  participant MCP as MCP\n  participant Exec as Executor\n  Stream-&gt;&gt;Strat: MarketBook update\n  Strat-&gt;&gt;MCP: probs \u2192 fair odds \u2192 edge\n  MCP--&gt;&gt;Strat: recommendation (BACK/NO_BET)\n  Strat-&gt;&gt;Exec: place limit order (if edge\u2265th)\n  Strat-&gt;&gt;Prom: update metrics\n  Note over Strat: Circuit breakers enforce limits\n</code></pre>"},{"location":"ai-ml-explained/#ml-lifecycle-future","title":"ML lifecycle (future)","text":"<pre><code>flowchart TB\n  Hist[Historical data] --&gt; Train[Train model]\n  Train --&gt; Validate[Backtest &amp; CV]\n  Validate --&gt;|model.pkl| API[Prediction API]\n  Live[Live stream] --&gt; Inplay[In-play features]\n  Inplay --&gt; API\n  API --&gt; Agent\n  Agent --&gt; Logs[Results &amp; metrics]\n  Logs --&gt;|retrain| Train\n</code></pre>"},{"location":"ai-ml-explained/#verification-validation","title":"Verification &amp; Validation","text":"<p>Offline (before money) - Backtests: replay historical odds/settlements to verify profitability and variance. - Calibration: check if predicted probabilities match actual frequencies (Brier/ECE). - Ablations: show that value threshold and Kelly cap reduce drawdowns.</p> <p>Online (live, safe) - SIM shadow: paper trade for \u226524h; monitor ROI and P/L. \ue200cite\ue202turn0search0\ue201 - A/B: small stake REAL vs SIM; promote only if REAL beats baseline over sufficient matches. - Alerting: trip stop\u2011loss quickly; pause &amp; investigate.</p>"},{"location":"architecture-advanced/","title":"Architecture \u2014 Advanced View","text":"<p>This page adds deployment, security, scaling, and failure-mode views on top of the big picture.</p>"},{"location":"architecture-advanced/#deployment-kubernetes-openshift","title":"Deployment (Kubernetes / OpenShift)","text":"<pre><code>flowchart LR\n  subgraph Namespace\n    A[Agent Pod (Flumine + MCP)] --&gt;|/metrics| P[Prometheus]\n    A --&gt;|/events JSONL| G[UI-Gateway Sidecar]\n    G --&gt;|/api/events, /simulate| UI[Next.js UI (separate Pod)]\n    P --&gt; Gr[Grafana]\n  end\n  UI --&gt; Ingress[\"Ingress/Route + TLS\"]\n  UI -- OIDC --&gt; IdP[(Auth0/Keycloak)]\n  classDef k8s fill:#1f2937,stroke:#374151,color:#e5e7eb\n  class Namespace,Ingress k8s\n</code></pre> <p>Key: The UI proxies <code>/api/sse</code>, <code>/api/simulate</code>, and <code>/api/metrics_summary</code> so tokens remain in cookies.</p>"},{"location":"architecture-advanced/#securitydata-flow","title":"Security/Data-flow","text":"<pre><code>sequenceDiagram\n  participant Browser\n  participant UI as Next.js (Server Route)\n  participant GW as UI Gateway (FastAPI)\n  participant Agent\n  participant Prom as Prometheus\n  participant IdP as OIDC IdP\n\n  Browser-&gt;&gt;UI: GET /api/sse (cookie)\n  UI-&gt;&gt;IdP: validate session (server-side)\n  UI-&gt;&gt;GW: GET /api/events (Bearer from session)\n  GW-&gt;&gt;Agent: tail events.jsonl\n  Agent--&gt;&gt;GW: event lines\n  GW--&gt;&gt;UI: text/event-stream\n  UI--&gt;&gt;Browser: text/event-stream\n\n  Browser-&gt;&gt;UI: POST /api/simulate (cookie)\n  UI-&gt;&gt;GW: POST /simulate (Bearer)\n  GW-&gt;&gt;Agent: read recent mcp_evaluation\n  GW--&gt;&gt;UI: preview decisions\n  UI--&gt;&gt;Browser: JSON\n\n  UI-&gt;&gt;GW: GET /api/metrics_summary\n  GW-&gt;&gt;Prom: query /api/v1/query\n</code></pre>"},{"location":"architecture-advanced/#scaling-availability","title":"Scaling &amp; Availability","text":"<ul> <li>Horizontally scale UI (stateless). SSE proxy is light; consider sticky sessions if needed.</li> <li>Scale Agent:</li> <li>One agent per competition (shard markets) to avoid duplicate orders.</li> <li>Use leader election or partition by market id hash.</li> <li>Storage: switch events JSONL to a lightweight queue (e.g., NATS/Redis Stream) for multi-agent fan\u2011in.</li> <li>Resilience: circuit breakers (stop\u2011loss), health checks, retry on IdP/Prom outages.</li> </ul>"},{"location":"architecture-advanced/#failure-modes-mitigations","title":"Failure Modes &amp; Mitigations","text":"<ul> <li>IdP down \u2192 cached session or read-only mode (no new bets).</li> <li>Prom down \u2192 UI hides metrics; agent continues.</li> <li>Exchange stream stalls \u2192 watchdog; reconnect; halt orders when stale.</li> <li>Prediction API down \u2192 fallback to baseline probs; raise alert.</li> </ul>"},{"location":"architecture/","title":"Architecture (Big Picture)","text":"<pre><code>flowchart LR\n  subgraph UI[\"Next.js UI\"]\n    A1[\"MCP Console&lt;br/&gt;SSE Edge Chart\"]\n    A2[\"/api/sse &amp; /api/simulate proxies\"]\n  end\n  subgraph GW[\"UI Gateway (FastAPI)\"]\n    G1[\"/api/events (SSE)\"]\n    G2[\"/simulate (dry-run)\"]\n    G3[\"/api/metrics_summary (Prom API)\"]\n  end\n  subgraph Agent[\"Agent (Flumine + Model)\"]\n    S1[\"Stream API (odds)\"]\n    S2[\"MCP evaluate&lt;br/&gt;edge &amp; decision\"]\n    S3[\"Prometheus /metrics\"]\n    S4[\"Events JSONL\"]\n  end\n  subgraph Obs[\"Observability\"]\n    P[\"Prometheus\"]\n    Gr[\"Grafana\"]\n  end\n  UI --&gt;|\"SSE proxy\"| GW\n  GW --&gt;|\"tail events\"| Agent\n  Agent --&gt;|\"metrics\"| P\n  P --&gt; Gr\n  GW --&gt;|\"Prom HTTP API\"| P\n  Agent --&gt;|\"orders\"| BF[(Betfair Exchange)]\n  Agent --&gt;|\"Prediction API (optional)\"| MODEL[(Prediction Service)]\n  GW --&gt; UI\n</code></pre> <p>Why this design?</p> <ul> <li>The UI uses server-side proxies so tokens live in cookies (no secrets in the browser).</li> <li>The Gateway unifies live streaming (SSE), simulation previews, and metrics.</li> <li>The Agent stays focused on market + model logic, emitting events &amp; metrics.</li> <li>Prometheus/Grafana provide transparent, real-time observability.</li> </ul>"},{"location":"backtest-synthetic/","title":"Synthetic Backtest \u2014 Equity, Drawdown, and EV by Edge Bin","text":"<p>We simulate a simple market/model to illustrate expected vs realized behavior when betting only when edge \u2265 \u03c4.</p> <ul> <li>Equity curve \u2014 cumulative normalized bankroll.</li> <li>Drawdown curve \u2014 peak\u2011to\u2011trough losses over time.</li> <li>EV by edge bin \u2014 expected EV vs realized ROI per bet across edge buckets.</li> </ul> <p> </p> <p>Takeaways - Higher edges tend to map to higher EV (but with noise). - Drawdowns are inevitable; use stop\u2011loss and exposure caps. - Choose a conservative threshold \u03c4 to balance coverage and quality.</p>"},{"location":"calibration-comparison/","title":"Calibration \u2014 Model vs Baseline (Same Axes)","text":"<p>We compare our model against a baseline in a single reliability plot. Curves closer to the diagonal indicate better calibration (predicted probabilities match observed frequencies).</p> <p></p> <p>Why this matters: Calibrated probabilities reduce false edges and stabilize stake sizing.</p>"},{"location":"calibration-demo/","title":"Calibration Demo \u2014 Reliability, ROC, and PR Curves","text":"<p>This page shows how to assess probability quality and discrimination using a small synthetic example.</p> <p>We generate a toy dataset of predicted probabilities and true outcomes, then produce: - Reliability (calibration) curve \u2014 do predicted probabilities match observed frequencies? - ROC curve (AUC) \u2014 ranking quality. - Precision\u2013Recall curve (AUC) \u2014 especially relevant for class imbalance.</p> <p> </p>"},{"location":"calibration-demo/#how-to-read-these-plots","title":"How to read these plots","text":"<ul> <li>Reliability: line near the diagonal = well-calibrated; above it = under-confident; below = over-confident.</li> <li>ROC: closer to top-left is better; AUC \u2208 [0.5, 1.0].</li> <li>PR: higher precision for a given recall is better; area summarizes performance when positives are rare.</li> </ul> <p>In our betting context, calibrated probabilities make edge detection and stake sizing more reliable.</p>"},{"location":"calibration-evaluation/","title":"Evaluation &amp; Calibration","text":""},{"location":"calibration-evaluation/#proper-scoring-rules","title":"Proper scoring rules","text":"<ul> <li>Log loss (cross-entropy) \u2014 penalizes overconfident wrong predictions.</li> <li>Brier score \u2014 mean squared error of probabilities.</li> </ul>"},{"location":"calibration-evaluation/#ranking-discrimination","title":"Ranking &amp; discrimination","text":"<ul> <li>ROC-AUC, PR-AUC \u2014 how well probabilities separate outcomes.</li> </ul>"},{"location":"calibration-evaluation/#calibration","title":"Calibration","text":"<ul> <li>Reliability diagrams; temperature scaling, Platt, isotonic.</li> <li>Calibrated probs \u2192 stable edges \u2192 consistent staking.</li> </ul>"},{"location":"calibration-evaluation/#business-metrics","title":"Business metrics","text":"<ul> <li>Expected value (EV) of bets, realized P/L, ROI, drawdown.</li> <li>Coverage (how often we bet) vs selectivity (edge threshold).</li> </ul>"},{"location":"diagrams/","title":"Diagrams","text":""},{"location":"diagrams/#agent-event-loop","title":"Agent Event Loop","text":"<pre><code>sequenceDiagram\n  participant Stream as Exchange Stream\n  participant Agent\n  participant MCP\n  participant Exec as Execution\n  Stream-&gt;&gt;Agent: Odds update\n  Agent-&gt;&gt;MCP: Evaluate (P_A, P_B, O_A, O_B)\n  MCP--&gt;&gt;Agent: rec, edge, stake\n  Agent-&gt;&gt;Exec: Place order (if any)\n  Agent--&gt;&gt;Prom: Metrics\n  Agent--&gt;&gt;UI: Events JSONL (via gateway)\n</code></pre>"},{"location":"github-pages/","title":"Publish Docs on GitHub Pages (Step\u2011by\u2011Step)","text":"<p>This repo already includes a CI workflow at <code>.github/workflows/docs.yml</code> that: 1) Builds the MkDocs site into <code>./site</code>, and 2) Publishes it to the <code>gh-pages</code> branch using <code>GITHUB_TOKEN</code>.</p> <p>Follow these steps to enable Pages:</p>"},{"location":"github-pages/#1-ensure-actions-can-push-to-gh-pages","title":"1) Ensure Actions can push to <code>gh-pages</code>","text":"<ul> <li>Go to Repository \u2192 Settings \u2192 Actions \u2192 General </li> <li>Workflow permissions: select \u201cRead and write permissions.\u201d </li> <li>Save.</li> <li>If your org enforces branch protections, allow GitHub Actions to push to <code>gh-pages</code> (or create an exception).</li> </ul>"},{"location":"github-pages/#2-enable-pages","title":"2) Enable Pages","text":"<ul> <li>Go to Repository \u2192 Settings \u2192 Pages </li> <li>Source: Deploy from a branch </li> <li>Branch: select <code>gh-pages</code>, / (root) </li> <li>Save.   GitHub will show your docs URL, e.g. <code>https://&lt;user&gt;.github.io/&lt;repo&gt;/</code>.</li> </ul> <p>The first publish happens after the next push to <code>main</code> that touches <code>docs/**</code> or <code>mkdocs.yml</code>.</p>"},{"location":"github-pages/#3-run-the-workflow","title":"3) Run the workflow","text":"<ul> <li>Commit and push any change under <code>docs/</code>:   <pre><code>echo \"\" &gt;&gt; docs/index.md\ngit add docs/index.md &amp;&amp; git commit -m \"trigger docs publish\" &amp;&amp; git push\n</code></pre></li> <li>Watch Actions \u2192 Build &amp; Publish Docs; on success, Pages serves your site.</li> </ul>"},{"location":"github-pages/#4-optional-custom-domain","title":"4) (Optional) Custom domain","text":"<ul> <li>Create <code>CNAME</code> in repo root (or in <code>docs/</code> then configure MkDocs to include it) with your domain:   <pre><code>docs.example.com\n</code></pre></li> <li>Point your DNS to GitHub Pages per the official docs.</li> <li>In Settings \u2192 Pages, set the custom domain; GitHub will provision TLS automatically.</li> </ul>"},{"location":"github-pages/#5-optional-private-repositories","title":"5) (Optional) Private repositories","text":"<ul> <li>GitHub Pages for private repos requires an appropriate plan. If restricted, consider:</li> <li>Publishing the site from a public mirror repo,</li> <li>Or self-hosting the static <code>site/</code> via any web server / S3 + CloudFront.</li> </ul>"},{"location":"github-pages/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>404 / old content: Clear browser cache, ensure Pages is set to <code>gh-pages</code>, confirm the workflow pushed <code>site/</code> contents.</li> <li>Action cannot push: Check Workflow permissions, branch protection, or use a PAT with <code>contents:write</code> (then set it as a secret and pass it to the gh-pages action).</li> </ul>"},{"location":"helm/","title":"Helm \u2014 Deploying the Stack","text":"<p><pre><code>helm upgrade --install tennis charts/tennis -n tennis --create-namespace   --set agent.mode=SIM   --set ui.enabled=true\n</code></pre> - UI will expose <code>/api/sse</code>, <code>/api/metrics_summary</code>, <code>/api/simulate</code>. - Configure Ingress + TLS via <code>.Values.ui.ingress.*</code>. - Enable Prometheus Operator for ServiceMonitor/PrometheusRule.</p>"},{"location":"mcp/","title":"MCP &amp; Strategy","text":""},{"location":"mcp/#elevator-pitch","title":"Elevator pitch","text":"<p>Estimate win probabilities, compute fair odds, compare to market odds, place bets when edge \u2265 threshold, size stakes with capped Kelly, and observe everything.</p>"},{"location":"mcp/#explain-like-im-five-eli5","title":"Explain like I'm five (ELI5)","text":"<p>Imagine a smart friend who guesses how likely each player is to win. If the website's prize looks too generous compared to that chance, the friend says: bet a small amount. Otherwise: wait.</p>"},{"location":"mcp/#explain-for-adults","title":"Explain for adults","text":"<p>We convert model probabilities to fair odds (1/p). When the market offers odds better (higher) than fair by a margin (edge), it's a value bet. We only act if edge \u2265 threshold and we cap stake size to protect the bankroll.</p>"},{"location":"mcp/#for-engineers","title":"For engineers","text":"<p>Let P_A and P_B be model win probabilities, O_A, O_B the best back prices. - Fair odds: F_A = 1/P_A, F_B = 1/P_B. - Edge (odds form): E_A = (O_A - F_A)/F_A, E_B = (O_B - F_B)/F_B. - Act when E\\_{side} \\ge \\tau and O\\_{side}\\in[O_{min}, O_{max}]. - Stake (capped Kelly): f^* = \\min(\\max( (b p - (1-p))/b, 0), f_{max}), where b=O-1.</p> <pre><code>flowchart TD\n  A[\"Odds update\"] --&gt; B[\"Model probs (P_A, P_B)\"]\n  B --&gt; C[\"Fair odds (1/p)\"]\n  C --&gt; D[\"Edges vs market\"]\n  D --&gt;|E &gt;= threshold| E[\"Stake via capped Kelly\"]\n  D --&gt;|else| X[/NO BET/]\n  E --&gt; F[\"Place BACK order\"]\n</code></pre>"},{"location":"ml-basics/","title":"Machine Learning \u2014 The Basics","text":"<p>What is ML? Teaching computers to learn patterns from data and make predictions.</p> <p>In our case: Input features (player ratings, form, surface, H2H, etc.) \u2192 probability of Player A winning.</p>"},{"location":"ml-basics/#core-concepts","title":"Core concepts","text":"<ul> <li>Features: numeric signals (ELO, recent wins, serve stats).</li> <li>Label: match outcome (A wins = 1, else 0).</li> <li>Training: adjust model parameters to minimize error (e.g., log loss).</li> <li>Validation: test on unseen matches to estimate generalization.</li> <li>Calibration: ensure predicted probabilities match observed frequencies.</li> </ul>"},{"location":"ml-basics/#pictures","title":"Pictures","text":""},{"location":"openshift-uwm/","title":"OpenShift User Workload Monitoring (UWM) \u2014 Screenshots &amp; Checklist","text":"<p>Use OpenShift UWM to scrape app metrics in your project namespace.</p>"},{"location":"openshift-uwm/#checklist","title":"Checklist","text":"<ol> <li>Enable UWM in your cluster (cluster admin setting).</li> <li>Deploy this chart; ensure ServiceMonitor and PrometheusRule CRDs exist.</li> <li>Verify targets:</li> <li>OpenShift Console \u2192 Observe \u2192 Targets (Developer or Administrator view)</li> <li>Look for <code>tennis-agent</code> ServiceMonitor target.</li> <li>Verify rules &amp; alerts:</li> <li>Observe \u2192 Alerts: check <code>AgentDailyStopLossBreached</code>, <code>AgentNoData</code>, <code>AgentHighExposure</code>.</li> <li>Dashboards:</li> <li>Import <code>grafana/dashboards/agent.json</code> into Grafana (if not auto-discovered via ConfigMap label).</li> </ol>"},{"location":"openshift-uwm/#sample-screens-placeholders","title":"Sample Screens (placeholders)","text":"<p>Replace these placeholders with your actual screenshots once deployed.</p>"},{"location":"openshift/","title":"OpenShift Notes","text":"<ul> <li>Enable User Workload Monitoring (UWM) to scrape app namespaces.</li> <li>Confirm ServiceMonitor target is discovered under Observe \u2192 Targets.</li> <li>Use a Route to expose the UI; prefer edge termination TLS.</li> <li>RBAC &amp; SecurityContextConstraints may require tuning for images.</li> </ul>"},{"location":"prediction-modeling/","title":"Prediction Modeling (Deeper Dive)","text":""},{"location":"prediction-modeling/#feature-engineering","title":"Feature engineering","text":"<ul> <li>ELO &amp; Surface ELO: capture skill and surface specialization.</li> <li>Recent form: rolling win rates, last-N matches.</li> <li>Head-to-head: contextual indicator (small sample caution).</li> <li>Context: tournament level, round, fatigue proxies (rest days).</li> </ul>"},{"location":"prediction-modeling/#model-families","title":"Model families","text":"<ul> <li>Logistic regression: baseline, interpretable, well-calibrated with Platt scaling.</li> <li>Gradient boosting (e.g., XGBoost/LightGBM): handles nonlinearity &amp; interactions.</li> <li>Neural nets: flexible; require careful regularization &amp; data volume.</li> </ul>"},{"location":"prediction-modeling/#training-loop","title":"Training loop","text":"<ol> <li>Split data (time-aware) into train/val/test.</li> <li>Tune hyperparameters via cross-validation.</li> <li>Fit model on training; early stop on validation.</li> <li>Calibrate probabilities (Platt / isotonic) on validation.</li> <li>Final evaluation on test (log loss, Brier, ROC-AUC, calibration curve).</li> </ol>"},{"location":"prediction-modeling/#probability-calibration","title":"Probability calibration","text":"<p>A calibrated classifier outputs probabilities that match frequencies (buckets of 0.7 should win ~70%). Poor calibration impairs edge detection and stake sizing.</p>"},{"location":"prediction-modeling/#leakage-drift","title":"Leakage &amp; drift","text":"<ul> <li>Avoid using post-match info or outcome-correlated stats.</li> <li>Monitor concept drift (seasonality, new players, injuries) and retrain.</li> </ul>"},{"location":"risk-controls/","title":"Risk Controls","text":"<ul> <li>Edge threshold (\\tau): margin of safety against noise &amp; miscalibration.</li> <li>Stake cap (f_{max}): limits per-bet risk.</li> <li>Daily stop-loss / take-profit: circuit breakers.</li> <li>Exposure limit: cap unmatched liability.</li> <li>Kill-switch: manual or automated disable on anomalies.</li> </ul>"},{"location":"roc-pr-comparison/","title":"ROC/PR \u2014 Model vs Baseline","text":"<p>We compare discrimination of the model vs a baseline using ROC and Precision\u2013Recall curves.</p> <ul> <li>ROC AUC captures overall ranking quality.</li> <li>PR AUC is informative under class imbalance.</li> </ul> <p> </p>"},{"location":"security-auth/","title":"Security &amp; Auth","text":"<ul> <li>OIDC (Auth0/Keycloak): JWT access tokens validated via JWKS (gateway).</li> <li>SSE proxy: <code>/api/sse</code> keeps tokens in cookies; no query tokens.</li> <li>Simulate proxy: <code>/api/simulate</code> forwards securely to gateway.</li> <li>Secrets: Kubernetes Secrets &amp; restricted RBAC.</li> <li>Audit: events JSONL and Prometheus metrics for traceability.</li> </ul>"},{"location":"simulation-validation/","title":"Validation \u2014 Backtests &amp; Shadow Runs","text":"<ol> <li>Historical backtests: replay markets, compute decisions &amp; P/L.</li> <li>Shadow (SIM) runs: real-time, paper trading with live odds.</li> <li>Tournament sweeps: threshold grid-search for robust \\tau.</li> <li>A/B variants: compare model versions with common random numbers.</li> <li>Guardrails: stop-loss, max daily bets, exposure caps.</li> </ol> <p>Outputs: ROI distribution, win rate, EV stability, drawdowns, sensitivity to \\tau.</p>"},{"location":"threshold-sensitivity/","title":"Threshold Sensitivity \u2014 Reliability vs Edge Threshold","text":"<p>We evaluate probability quality on the subset we actually bet, as we raise the edge threshold \\tau.</p> <ul> <li>Metrics computed only on predictions with edge \u2265 \\tau.</li> <li>Lower Brier and Log loss indicate better calibration on the traded subset.</li> <li>Coverage drops as \\tau increases (fewer bets).</li> </ul> <p> </p> <p>Use this chart to pick a conservative \\tau that balances quality and coverage.</p>"},{"location":"ui/","title":"UI &amp; Gateway","text":"<p>The UI centers the MCP interaction: players, fair odds, probabilities, edge, and the live recommendation \u2014 with sliders to preview decisions.</p> <ul> <li>SSE: streamed via <code>/api/sse</code> proxy.</li> <li>Simulate: posted via <code>/api/simulate</code> proxy (tokens stay in cookies).</li> <li>Metrics: polled via <code>/api/metrics_summary</code> proxy.</li> </ul> <pre><code>sequenceDiagram\n  participant Browser\n  participant UI as Next.js Route (/api/sse)\n  participant GW as Gateway (/api/events)\n  Browser-&gt;&gt;UI: GET /api/sse\n  UI-&gt;&gt;GW: GET /api/events (Authorization: Bearer ...)\n  GW--&gt;&gt;UI: text/event-stream\n  UI--&gt;&gt;Browser: text/event-stream\n</code></pre>"},{"location":"notebooks/backtest/","title":"Backtest Notebook (Synthetic)","text":"In\u00a0[1]: Copied! <pre>import numpy as np, matplotlib.pyplot as plt\nfrom sklearn.metrics import roc_curve, auc, precision_recall_curve, brier_score_loss, log_loss\nrng = np.random.default_rng(123)\nn = 4000\np_true = rng.beta(2.0,2.0,size=n)\nlogit = np.log(p_true/(1-p_true))\np_model = 1/(1+np.exp(-(logit + rng.normal(0,0.45,size=n))))\np_model = np.clip(p_model, 1e-4,1-1e-4)\np_base  = 1/(1+np.exp(-(logit + rng.normal(0,0.95,size=n))))\np_base  = np.clip(p_base,  1e-4,1-1e-4)\ny = rng.binomial(1, p_true)\np_mkt = np.clip(p_true + rng.normal(0,0.08,size=n), 1e-3,1-1e-3)\nprice_mkt = 1.0 / p_mkt\nprice_fair_model = 1.0 / p_model\nedge = (price_mkt - price_fair_model) / price_fair_model\ndef kelly_fraction(p, price, fmax=0.05):\n    b = max(price-1.0, 0.0)\n    q = 1.0 - p\n    f = (b*p - q)/b if b&gt;0 else 0.0\n    return max(0.0, min(f, fmax))\nstakes = np.array([kelly_fraction(p, pr, 0.05) for p, pr in zip(p_model, price_mkt)])\ndo_bet = edge &gt;= 0.05\nstakes = stakes * do_bet\nwins = rng.binomial(1, p_true, size=n)\npl_steps = stakes * (wins * (price_mkt - 1.0) - (1 - wins))\nequity = 1.0 + np.cumsum(pl_steps)\npeak = np.maximum.accumulate(equity)\ndrawdown = (equity - peak) / peak\nplt.figure(); plt.plot(equity); plt.title('Equity Curve'); plt.xlabel('Bet index'); plt.ylabel('Equity'); plt.grid(True,alpha=0.3); plt.show()\nplt.figure(); plt.plot(drawdown); plt.title('Drawdown'); plt.xlabel('Bet index'); plt.ylabel('Drawdown'); plt.grid(True,alpha=0.3); plt.show()\nbins = np.array([-0.2,-0.1,0.0,0.02,0.05,0.08,0.12,0.2,0.5])\nids = np.digitize(edge, bins) - 1\ncenters, ev_exp, ev_real = [], [], []\nfor b in range(len(bins)-1):\n    m = ids==b\n    if m.sum()==0: continue\n    exp_ev = (p_model[m]*(price_mkt[m]-1.0) - (1.0 - p_model[m]))\n    st = stakes[m]\n    realized = np.where(st&gt;0, (wins[m]*(price_mkt[m]-1.0) - (1 - wins[m])), np.nan)\n    roi = realized[~np.isnan(realized)]\n    ev_exp.append(np.nanmean(exp_ev))\n    ev_real.append(np.nanmean(roi) if roi.size&gt;0 else np.nan)\n    centers.append(0.5*(bins[b]+bins[b+1]))\nplt.figure(); plt.plot(centers, ev_exp, marker='o', label='Expected EV per bet');\nplt.plot(centers, ev_real, marker='s', label='Realized ROI per bet');\nplt.axvline(0.05, linestyle='--', label='Edge threshold');\nplt.title('EV by Edge Bin'); plt.xlabel('Edge bin (center)'); plt.ylabel('Per-bet EV/ROI'); plt.grid(True,alpha=0.3); plt.legend(); plt.show()\n</pre> import numpy as np, matplotlib.pyplot as plt from sklearn.metrics import roc_curve, auc, precision_recall_curve, brier_score_loss, log_loss rng = np.random.default_rng(123) n = 4000 p_true = rng.beta(2.0,2.0,size=n) logit = np.log(p_true/(1-p_true)) p_model = 1/(1+np.exp(-(logit + rng.normal(0,0.45,size=n)))) p_model = np.clip(p_model, 1e-4,1-1e-4) p_base  = 1/(1+np.exp(-(logit + rng.normal(0,0.95,size=n)))) p_base  = np.clip(p_base,  1e-4,1-1e-4) y = rng.binomial(1, p_true) p_mkt = np.clip(p_true + rng.normal(0,0.08,size=n), 1e-3,1-1e-3) price_mkt = 1.0 / p_mkt price_fair_model = 1.0 / p_model edge = (price_mkt - price_fair_model) / price_fair_model def kelly_fraction(p, price, fmax=0.05):     b = max(price-1.0, 0.0)     q = 1.0 - p     f = (b*p - q)/b if b&gt;0 else 0.0     return max(0.0, min(f, fmax)) stakes = np.array([kelly_fraction(p, pr, 0.05) for p, pr in zip(p_model, price_mkt)]) do_bet = edge &gt;= 0.05 stakes = stakes * do_bet wins = rng.binomial(1, p_true, size=n) pl_steps = stakes * (wins * (price_mkt - 1.0) - (1 - wins)) equity = 1.0 + np.cumsum(pl_steps) peak = np.maximum.accumulate(equity) drawdown = (equity - peak) / peak plt.figure(); plt.plot(equity); plt.title('Equity Curve'); plt.xlabel('Bet index'); plt.ylabel('Equity'); plt.grid(True,alpha=0.3); plt.show() plt.figure(); plt.plot(drawdown); plt.title('Drawdown'); plt.xlabel('Bet index'); plt.ylabel('Drawdown'); plt.grid(True,alpha=0.3); plt.show() bins = np.array([-0.2,-0.1,0.0,0.02,0.05,0.08,0.12,0.2,0.5]) ids = np.digitize(edge, bins) - 1 centers, ev_exp, ev_real = [], [], [] for b in range(len(bins)-1):     m = ids==b     if m.sum()==0: continue     exp_ev = (p_model[m]*(price_mkt[m]-1.0) - (1.0 - p_model[m]))     st = stakes[m]     realized = np.where(st&gt;0, (wins[m]*(price_mkt[m]-1.0) - (1 - wins[m])), np.nan)     roi = realized[~np.isnan(realized)]     ev_exp.append(np.nanmean(exp_ev))     ev_real.append(np.nanmean(roi) if roi.size&gt;0 else np.nan)     centers.append(0.5*(bins[b]+bins[b+1])) plt.figure(); plt.plot(centers, ev_exp, marker='o', label='Expected EV per bet'); plt.plot(centers, ev_real, marker='s', label='Realized ROI per bet'); plt.axvline(0.05, linestyle='--', label='Edge threshold'); plt.title('EV by Edge Bin'); plt.xlabel('Edge bin (center)'); plt.ylabel('Per-bet EV/ROI'); plt.grid(True,alpha=0.3); plt.legend(); plt.show()"},{"location":"notebooks/backtest/#backtest-notebook-synthetic","title":"Backtest Notebook (Synthetic)\u00b6","text":"<p>Simulates a simple market/model and visualizes equity, drawdown, and EV by edge bin.</p>"},{"location":"notebooks/calibration_platt_isotonic/","title":"Calibration Demo \u2014 Platt &amp; Isotonic","text":""},{"location":"notebooks/calibration_platt_isotonic/#calibration-demo-platt-isotonic","title":"Calibration Demo \u2014 Platt &amp; Isotonic\u00b6","text":""},{"location":"runbooks/prod-cutover/","title":"Runbook \u2014 Production Cutover","text":"<ol> <li>Start with tiny stakes; set strict daily stop-loss.</li> <li>Monitor alerts (stop-loss breach, no-data, high exposure).</li> <li>Gradually increase bankroll allocation and f_{max}.</li> <li>Post-mortem unexpected losses; adjust \\tau, calibration.</li> <li>Weekly retraining &amp; dashboard review.</li> </ol>"},{"location":"runbooks/sim-shadow/","title":"Runbook \u2014 SIM / Shadow","text":"<ol> <li>Deploy Helm chart with <code>agent.mode=SIM</code>.</li> <li>Confirm <code>/metrics</code> scraped; Grafana dashboard shows evaluations.</li> <li>Verify <code>/api/sse</code> streams events into UI; Decision Feed updates.</li> <li>Tune thresholds with a small set of tournaments.</li> <li>Review daily: bets count, ROI, edge distributions.</li> </ol>"}]}